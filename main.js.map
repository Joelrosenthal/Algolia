{"version":3,"sources":["jquery.typeahead.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["/*!\n * jQuery Typeahead\n * Copyright (C) 2016 RunningCoder.org\n * Licensed under the MIT license\n *\n * @author Tom Bertrand\n * @version 2.7.2 (2016-10-26)\n * @link http://www.runningcoder.org/jquerytypeahead/\n */\n;(function (factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('jquery-typeahead', ['jquery'], function (jQuery) {\n            return factory(jQuery);\n        });\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = function (jQuery, root) {\n            if (jQuery === undefined) {\n                if (typeof window !== 'undefined') {\n                    jQuery = require('jquery');\n                }\n                else {\n                    jQuery = require('jquery')(root);\n                }\n            }\n            return factory(jQuery);\n        };\n    } else {\n        factory(jQuery);\n    }\n}(function ($) {\n\n    \"use strict\";\n\n    window.Typeahead = {\n        version: '2.7.2'\n    };\n\n    /**\n     * @private\n     * Default options\n     *\n     * @link http://www.runningcoder.org/jquerytypeahead/documentation/\n     */\n    var _options = {\n        input: null,\n        minLength: 2,           // Modified feature, now accepts 0 to search on focus\n        maxItem: 8,             // Modified feature, now accepts 0 as \"Infinity\" meaning all the results will be displayed\n        dynamic: false,\n        delay: 300,\n        order: null,            // ONLY sorts the first \"display\" key\n        offset: false,\n        hint: false,            // -> Improved feature, Added support for excessive \"space\" characters\n        accent: false,          // -> Improved feature, define a custom replacement object\n        highlight: true,        // -> Added \"any\" to highlight any word in the template, by default true will only highlight display keys\n        group: false,           // -> Improved feature, Boolean,string,object(key, template (string, function))\n        groupOrder: null,       // -> New feature, order groups \"asc\", \"desc\", Array, Function\n        maxItemPerGroup: null,  // -> Renamed option\n        dropdownFilter: false,  // -> Renamed option, true will take group options string will filter on object key\n        dynamicFilter: null,    // -> New feature, filter the typeahead results based on dynamic value, Ex: Players based on TeamID\n        backdrop: false,\n        backdropOnFocus: false, // -> New feature, display the backdrop option as the Typeahead input is :focused\n        cache: false,           // -> Improved option, true OR 'localStorage' OR 'sessionStorage'\n        ttl: 3600000,\n        compression: false,     // -> Requires LZString library\n        suggestion: false,      // -> *Coming soon* New feature, save last searches and display suggestion on matched characters\n        searchOnFocus: false,   // -> New feature, display search results on input focus\n        resultContainer: null,  // -> New feature, list the results inside any container string or jQuery object\n        generateOnLoad: null,   // -> New feature, forces the source to be generated on page load even if the input is not focused!\n        mustSelectItem: false,  // -> New option, the submit function only gets called if an item is selected\n        href: null,             // -> New feature, String or Function to format the url for right-click & open in new tab on link results\n        display: [\"display\"],   // -> Improved feature, allows search in multiple item keys [\"display1\", \"display2\"]\n        template: null,\n        groupTemplate: null,    // -> New feature, set a custom template for the groups\n        correlativeTemplate: false, // -> New feature, compile display keys, enables multiple key search from the template string\n        emptyTemplate: false,   // -> New feature, display an empty template if no result\n        cancelButton: true,     // -> New feature, if text is detected in the input, a cancel button will be available to reset the input (pressing ESC also cancels)\n        loadingAnimation: true, // -> New feature, will display a loading animation when typeahead is doing request / searching for results\n        filter: true,           // -> New feature, set to false or function to bypass Typeahead filtering. WARNING: accent, correlativeTemplate, offset & matcher will not be interpreted\n        matcher: null,          // -> New feature, add an extra filtering function after the typeahead functions\n        source: null,\n        callback: {\n            onInit: null,\n            onReady: null,              // -> New callback, when the Typeahead initial preparation is completed\n            onShowLayout: null,         // -> New callback, called when the layout is shown\n            onHideLayout: null,         // -> New callback, called when the layout is hidden\n            onSearch: null,             // -> New callback, when data is being fetched & analyzed to give search results\n            onResult: null,\n            onLayoutBuiltBefore: null,  // -> New callback, when the result HTML is build, modify it before it get showed\n            onLayoutBuiltAfter: null,   // -> New callback, modify the dom right after the results gets inserted in the result container\n            onNavigateBefore: null,     // -> New callback, when a key is pressed to navigate the results\n            onNavigateAfter: null,      // -> New callback, when a key is pressed to navigate the results\n            onMouseEnter: null,\n            onMouseLeave: null,\n            onClickBefore: null,        // -> Improved feature, possibility to e.preventDefault() to prevent the Typeahead behaviors\n            onClickAfter: null,         // -> New feature, happens after the default clicked behaviors has been executed\n            onSendRequest: null,        // -> New callback, gets called when the Ajax request(s) are sent\n            onReceiveRequest: null,     // -> New callback, gets called when the Ajax request(s) are all received\n            onPopulateSource: null,     // -> New callback, Perform operation on the source data before it gets in Typeahead data\n            onCacheSave: null,          // -> New callback, Perform operation on the source data before it gets in Typeahead cache\n            onSubmit: null,\n            onCancel: null              // -> New callback, triggered if the typeahead had text inside and is cleared\n        },\n        selector: {\n            container: \"typeahead__container\",\n            result: \"typeahead__result\",\n            list: \"typeahead__list\",\n            group: \"typeahead__group\",\n            item: \"typeahead__item\",\n            empty: \"typeahead__empty\",\n            display: \"typeahead__display\",\n            query: \"typeahead__query\",\n            filter: \"typeahead__filter\",\n            filterButton: \"typeahead__filter-button\",\n            dropdown: \"typeahead__dropdown\",\n            dropdownItem: \"typeahead__dropdown-item\",\n            button: \"typeahead__button\",\n            backdrop: \"typeahead__backdrop\",\n            hint: \"typeahead__hint\",\n            cancelButton: \"typeahead__cancel-button\"\n        },\n        debug: false\n    };\n\n    /**\n     * @private\n     * Event namespace\n     */\n    var _namespace = \".typeahead\";\n\n    /**\n     * @private\n     * Accent equivalents\n     */\n    var _accent = {\n        from: \"ãàáäâẽèéëêìíïîõòóöôùúüûñç\",\n        to: \"aaaaaeeeeeiiiiooooouuuunc\"\n    };\n\n    /**\n     * #62 IE9 doesn't trigger \"input\" event when text gets removed (backspace, ctrl+x, etc)\n     * @private\n     */\n    var _isIE9 = ~window.navigator.appVersion.indexOf(\"MSIE 9.\");\n\n    /**\n     * #193 Clicking on a suggested option does not select it on IE10/11\n     * @private\n     */\n    var _isIE10 = ~window.navigator.appVersion.indexOf(\"MSIE 10\");\n    var _isIE11 = ~window.navigator.userAgent.indexOf(\"Trident\") && ~window.navigator.userAgent.indexOf(\"rv:11\");\n\n    // SOURCE GROUP RESERVED WORDS: ajax, data, url\n    // SOURCE ITEMS RESERVED KEYS: group, display, data, matchedKey, compiled, href\n\n    /**\n     * @constructor\n     * Typeahead Class\n     *\n     * @param {object} node jQuery input object\n     * @param {object} options User defined options\n     */\n    var Typeahead = function (node, options) {\n\n        this.rawQuery = node.val() || '';   // Unmodified input query\n        this.query = node.val() || '';      // Input query\n        this.namespace = '.' + _namespace; // Every Typeahead instance gets its own namespace for events\n        this.tmpSource = {};                // Temp var to preserve the source order for the searchResult function\n        this.source = {};                   // The generated source kept in memory\n        this.isGenerated = null;            // Generated results -> null: not generated, false: generating, true generated\n        this.generatedGroupCount = 0;       // Number of groups generated, if limit reached the search can be done\n        this.groupCount = 0;                // Number of groups, this value gets counted on the initial source unification\n        this.groupBy = \"group\";             // This option will change according to filtering or custom grouping\n        this.groups = [];                   // Array of all the available groups, used to build the groupTemplate\n        this.result = {};                   // Results based on Source-query match (only contains the displayed elements)\n        this.groupTemplate = '';            // Result template at the {{group}} level\n        this.resultHtml = null;             // HTML Results (displayed elements)\n        this.resultCount = 0;               // Total results based on Source-query match\n        this.resultCountPerGroup = {};      // Total results based on Source-query match per group\n        this.options = options;             // Typeahead options (Merged default & user defined)\n        this.node = node;                   // jQuery object of the Typeahead <input>\n        this.namespace = '.' +              // Every Typeahead instance gets its own namespace for events\n            this.helper.slugify.call(this, node.selector) +\n            _namespace;\n        this.container = null;              // Typeahead container, usually right after <form>\n        this.resultContainer = null;        // Typeahead result container (html)\n        this.item = null;                   // The selected item\n        this.xhr = {};                      // Ajax request(s) stack\n        this.hintIndex = null;              // Numeric value of the hint index in the result list\n        this.filters = {                    // Filter list for searching, dropdown and dynamic(s)\n            dropdown: {},                   // Dropdown menu if options.dropdownFilter is set\n            dynamic: {}                     // Checkbox / Radio / Select to filter the source data\n        };\n        this.dropdownFilter = {\n            static: [],                     // Objects that has a value\n            dynamic: []\n        };\n        this.dropdownFilterAll = null;      // The last \"all\" definition\n\n        this.requests = {};                 // Store the group:request instead of generating them every time\n\n        this.backdrop = {};                 // The backdrop object\n        this.hint = {};                     // The hint object\n        this.hasDragged = false;            // Will cancel mouseend events if true\n        this.focusOnly = false;             // Focus the input preventing any operations\n\n        this.__construct();\n\n    };\n\n    Typeahead.prototype = {\n\n        extendOptions: function () {\n\n            // If the Typeahead is dynamic, force no cache & no compression\n            if (this.options.dynamic) {\n                this.options.cache = false;\n                this.options.compression = false;\n            }\n\n            var scope = this;\n\n            if (this.options.cache) {\n                this.options.cache = (function (cache) {\n\n                    var supportedCache = ['localStorage', 'sessionStorage'],\n                        supported;\n\n                    if (cache === true) {\n                        cache = 'localStorage';\n                    } else if (typeof cache === \"string\" && !~supportedCache.indexOf(cache)) {\n                        // {debug}\n                        if (scope.options.debug) {\n                            _debug.log({\n                                'node': scope.node.selector,\n                                'function': 'extendOptions()',\n                                'message': 'Invalid options.cache, possible options are \"localStorage\" or \"sessionStorage\"'\n                            });\n\n                            _debug.print();\n                        }\n                        // {/debug}\n                        return false;\n                    }\n\n                    supported = typeof window[cache] !== \"undefined\";\n\n                    try {\n                        window[cache].setItem(\"typeahead\", \"typeahead\");\n                        window[cache].removeItem(\"typeahead\");\n                    } catch (e) {\n                        supported = false;\n                    }\n\n                    return supported && cache || false;\n                }).call(this, this.options.cache);\n            }\n\n            if (this.options.compression) {\n                if (typeof LZString !== 'object' || !this.options.cache) {\n                    // {debug}\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'extendOptions()',\n                            'message': 'Missing LZString Library or options.cache, no compression will occur.'\n                        });\n\n                        _debug.print();\n                    }\n                    // {/debug}\n                    this.options.compression = false;\n                }\n            }\n\n            if (typeof this.options.maxItem !== \"undefined\" && (!/^\\d+$/.test(this.options.maxItem) || this.options.maxItem === 0)) {\n                this.options.maxItem = Infinity;\n            }\n\n            if (this.options.maxItemPerGroup && !/^\\d+$/.test(this.options.maxItemPerGroup)) {\n                this.options.maxItemPerGroup = null;\n            }\n\n            if (this.options.display && !Array.isArray(this.options.display)) {\n                this.options.display = [this.options.display];\n            }\n\n            if (this.options.group) {\n                if (!Array.isArray(this.options.group)) {\n                    if (typeof this.options.group === \"string\") {\n                        this.options.group = {\n                            key: this.options.group\n                        };\n                    } else if (typeof this.options.group === \"boolean\") {\n                        this.options.group = {\n                            key: 'group'\n                        };\n                    }\n\n                    this.options.group.key = this.options.group.key || \"group\";\n                }\n                // {debug}\n                else {\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'extendOptions()',\n                            'message': 'options.group must be a boolean|string|object as of 2.5.0'\n                        });\n\n                        _debug.print();\n                    }\n                }\n                // {/debug}\n            }\n\n            if (this.options.highlight && !~[\"any\", true].indexOf(this.options.highlight)) {\n                this.options.highlight = false;\n            }\n\n            if (this.options.dropdownFilter && this.options.dropdownFilter instanceof Object) {\n                if (!Array.isArray(this.options.dropdownFilter)) {\n                    this.options.dropdownFilter = [this.options.dropdownFilter];\n                }\n                for (var i = 0, ii = this.options.dropdownFilter.length; i < ii; ++i) {\n                    this.dropdownFilter[this.options.dropdownFilter[i].value ? 'static' : 'dynamic'].push(this.options.dropdownFilter[i]);\n                }\n            }\n\n            if (this.options.dynamicFilter && !Array.isArray(this.options.dynamicFilter)) {\n                this.options.dynamicFilter = [this.options.dynamicFilter];\n            }\n\n            if (this.options.accent) {\n                if (typeof this.options.accent === \"object\") {\n                    if (this.options.accent.from && this.options.accent.to && this.options.accent.from.length === this.options.accent.to.length) {\n\n                    }\n                    // {debug}\n                    else {\n                        if (this.options.debug) {\n                            _debug.log({\n                                'node': this.node.selector,\n                                'function': 'extendOptions()',\n                                'message': 'Invalid \"options.accent\", from and to must be defined and same length.'\n                            });\n\n                            _debug.print();\n                        }\n                    }\n                    // {/debug}\n                } else {\n                    this.options.accent = _accent;\n                }\n            }\n\n            if (this.options.groupTemplate) {\n                this.groupTemplate = this.options.groupTemplate;\n            }\n\n            if (this.options.resultContainer) {\n                if (typeof this.options.resultContainer === \"string\") {\n                    this.options.resultContainer = $(this.options.resultContainer);\n                }\n\n                if (!(this.options.resultContainer instanceof $) || !this.options.resultContainer[0]) {\n                    // {debug}\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'extendOptions()',\n                            'message': 'Invalid jQuery selector or jQuery Object for \"options.resultContainer\".'\n                        });\n\n                        _debug.print();\n                    }\n                    // {/debug}\n                } else {\n                    this.resultContainer = this.options.resultContainer;\n                }\n            }\n\n            if (this.options.maxItemPerGroup && this.options.group && this.options.group.key) {\n                this.groupBy = this.options.group.key;\n            }\n\n            // Compatibility onClick callback\n            if (this.options.callback && this.options.callback.onClick) {\n                this.options.callback.onClickBefore = this.options.callback.onClick;\n                delete this.options.callback.onClick;\n            }\n\n            // Compatibility onNavigate callback\n            if (this.options.callback && this.options.callback.onNavigate) {\n                this.options.callback.onNavigateBefore = this.options.callback.onNavigate;\n                delete this.options.callback.onNavigate;\n            }\n\n            this.options = $.extend(\n                true,\n                {},\n                _options,\n                this.options\n            );\n\n        },\n\n        unifySourceFormat: function () {\n\n            this.groupCount = 0;\n\n            // source: ['item1', 'item2', 'item3']\n            if (Array.isArray(this.options.source)) {\n                this.options.source = {\n                    group: {\n                        data: this.options.source\n                    }\n                };\n\n                this.groupCount = 1;\n                return true;\n            }\n\n            // source: \"http://www.test.com/url.json\"\n            if (typeof this.options.source === \"string\") {\n                this.options.source = {\n                    group: {\n                        ajax: {\n                            url: this.options.source\n                        }\n                    }\n                };\n            }\n\n            if (this.options.source.ajax) {\n                this.options.source = {\n                    group: {\n                        ajax: this.options.source.ajax\n                    }\n                };\n            }\n\n\n            // source: {data: ['item1', 'item2'], url: \"http://www.test.com/url.json\"}\n            if (this.options.source.url || this.options.source.data) {\n                this.options.source = {\n                    group: this.options.source\n                };\n            }\n\n            var group,\n                groupSource,\n                tmpAjax;\n\n            for (group in this.options.source) {\n                if (!this.options.source.hasOwnProperty(group)) continue;\n\n                groupSource = this.options.source[group];\n\n                // source: {group: \"http://www.test.com/url.json\"}\n                if (typeof groupSource === \"string\") {\n                    groupSource = {\n                        ajax: {\n                            url: groupSource\n                        }\n                    };\n                }\n\n                // source: {group: {url: [\"http://www.test.com/url.json\", \"json.path\"]}}\n                tmpAjax = groupSource.url || groupSource.ajax;\n                if (Array.isArray(tmpAjax)) {\n                    groupSource.ajax = typeof tmpAjax[0] === \"string\" ? {\n                        url: tmpAjax[0]\n                    } : tmpAjax[0];\n                    groupSource.ajax.path = groupSource.ajax.path || tmpAjax[1] || null;\n                    delete groupSource.url;\n                } else {\n                    // source: {group: {url: {url: \"http://www.test.com/url.json\", method: \"GET\"}}}\n                    // source: {group: {url: \"http://www.test.com/url.json\", dataType: \"jsonp\"}}\n                    if (typeof groupSource.url === \"object\") {\n                        groupSource.ajax = groupSource.url;\n                    } else if (typeof groupSource.url === \"string\") {\n                        groupSource.ajax = {\n                            url: groupSource.url\n                        };\n                    }\n                    delete groupSource.url;\n                }\n\n                if (!groupSource.data && !groupSource.ajax) {\n\n                    // {debug}\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'unifySourceFormat()',\n                            'arguments': JSON.stringify(this.options.source),\n                            'message': 'Undefined \"options.source.' + group + '.[data|ajax]\" is Missing - Typeahead dropped'\n                        });\n\n                        _debug.print();\n                    }\n                    // {/debug}\n\n                    return false;\n                }\n\n                if (groupSource.display && !Array.isArray(groupSource.display)) {\n                    groupSource.display = [groupSource.display];\n                }\n\n                this.options.source[group] = groupSource;\n\n                this.groupCount++;\n\n            }\n\n            return true;\n        },\n\n        init: function () {\n\n            this.helper.executeCallback.call(this, this.options.callback.onInit, [this.node]);\n\n            this.container = this.node.closest('.' + this.options.selector.container);\n\n            // {debug}\n            if (this.options.debug) {\n                _debug.log({\n                    'node': this.node.selector,\n                    'function': 'init()',\n                    //'arguments': JSON.stringify(this.options),\n                    'message': 'OK - Typeahead activated on ' + this.node.selector\n                });\n\n                _debug.print();\n            }\n            // {/debug}\n\n        },\n\n        delegateEvents: function () {\n\n            var scope = this,\n                events = [\n                    'focus' + this.namespace,\n                    'input' + this.namespace,\n                    'propertychange' + this.namespace,  // IE8 Fix\n                    'keydown' + this.namespace,\n                    'keyup' + this.namespace,           // IE9 Fix\n                    'dynamic' + this.namespace,\n                    'generate' + this.namespace\n                ];\n\n            // #149 - Adding support for Mobiles\n            $('html').on(\"touchmove\", function () {\n                scope.hasDragged = true;\n            }).on(\"touchstart\", function () {\n                scope.hasDragged = false;\n            });\n\n            this.node.closest('form').on(\"submit\", function (e) {\n                if (scope.options.mustSelectItem && scope.helper.isEmpty(scope.item)) {\n                    e.preventDefault();\n                    return;\n                }\n\n                if (!scope.options.backdropOnFocus) {\n                    scope.hideLayout();\n                }\n\n                if (scope.options.callback.onSubmit) {\n                    return scope.helper.executeCallback.call(scope, scope.options.callback.onSubmit, [scope.node, this, scope.item, e]);\n                }\n            }).on(\"reset\", function () {\n                // #221 - Reset Typeahead on form reset.\n                // setTimeout to re-queue the `input.typeahead` event at the end\n                setTimeout(function () {\n                    scope.node.trigger('input' + scope.namespace);\n                    // #243 - minLength: 0 opens the Typeahead results\n                    scope.hideLayout();\n                });\n            });\n\n            // IE8 fix\n            var preventNextEvent = false;\n\n            // IE10/11 fix\n            if (this.node.attr('placeholder') && (_isIE10 || _isIE11)) {\n                var preventInputEvent = true;\n\n                this.node.on(\"focusin focusout\", function () {\n                    preventInputEvent = !!(!this.value && this.placeholder);\n                });\n\n                this.node.on(\"input\", function (e) {\n                    if (preventInputEvent) {\n                        e.stopImmediatePropagation();\n                        preventInputEvent = false;\n                    }\n                });\n            }\n\n            this.node.off(this.namespace).on(events.join(' '), function (e, originalEvent) {\n\n                switch (e.type) {\n                    case \"generate\":\n                        scope.isGenerated = null;\n                        scope.generateSource();\n                        break;\n                    case \"focus\":\n                        if (scope.focusOnly) {\n                            scope.focusOnly = false;\n                            break;\n                        }\n                        if (scope.options.backdropOnFocus) {\n                            scope.buildBackdropLayout();\n                            scope.showLayout();\n                        }\n                        if (scope.options.searchOnFocus && scope.query.length >= scope.options.minLength) {\n                            if (scope.isGenerated) {\n                                scope.showLayout();\n                            } else if (scope.isGenerated === null) {\n                                scope.generateSource();\n                            }\n                        }\n                        break;\n                    case \"keydown\":\n                        if (e.keyCode && ~[9, 13, 27, 38, 39, 40].indexOf(e.keyCode)) {\n                            preventNextEvent = true;\n                            scope.navigate(e);\n                        }\n                        break;\n                    case \"keyup\":\n                        if (scope.isGenerated === null && !scope.options.dynamic) {\n                            scope.generateSource();\n                        }\n                        if (_isIE9 && scope.node[0].value.replace(/^\\s+/, '').toString().length < scope.query.length) {\n                            scope.node.trigger('input' + scope.namespace);\n                        }\n                        break;\n                    case \"propertychange\":\n                        if (preventNextEvent) {\n                            preventNextEvent = false;\n                            break;\n                        }\n                    case \"input\":\n\n                        scope.rawQuery = scope.node[0].value.toString();\n\n                        // #195 Trigger an onCancel event if the Typeahead is cleared\n                        if (scope.rawQuery === \"\" && scope.query !== \"\") {\n                            e.originalEvent = originalEvent || {};\n                            scope.helper.executeCallback.call(scope, scope.options.callback.onCancel, [scope.node, e]);\n                        }\n\n                        scope.query = scope.rawQuery.replace(/^\\s+/, '');\n\n                        scope.options.cancelButton && scope.toggleCancelButton();\n\n                        if (scope.options.hint && scope.hint.container && scope.hint.container.val() !== '') {\n                            if (scope.hint.container.val().indexOf(scope.rawQuery) !== 0) {\n                                scope.hint.container.val('');\n                            }\n                        }\n                        if (scope.options.dynamic) {\n                            scope.isGenerated = null;\n                            scope.helper.typeWatch(function () {\n                                if (scope.query.length >= scope.options.minLength) {\n                                    scope.generateSource();\n                                } else {\n                                    scope.hideLayout();\n                                }\n                            }, scope.options.delay);\n                            return;\n                        }\n                    case \"dynamic\":\n                        if (!scope.isGenerated) {\n                            break;\n                        }\n\n                        scope.searchResult();\n                        scope.buildLayout();\n\n                        if ((scope.result.length > 0 || (scope.options.emptyTemplate && scope.query !== \"\")) &&\n                            scope.query.length >= scope.options.minLength\n                        ) {\n                            scope.showLayout();\n                        } else {\n                            scope.hideLayout();\n                        }\n\n                        break;\n                }\n\n            });\n\n            if (this.options.generateOnLoad) {\n                this.node.trigger('generate' + this.namespace);\n            }\n\n        },\n\n        generateSource: function () {\n\n            if (this.isGenerated && !this.options.dynamic) {\n                return;\n            }\n\n            this.generatedGroupCount = 0;\n            this.isGenerated = false;\n            this.options.loadingAnimation && this.container.addClass('loading');\n\n            if (!this.helper.isEmpty(this.xhr)) {\n                for (var i in this.xhr) {\n                    if (!this.xhr.hasOwnProperty(i)) continue;\n                    this.xhr[i].abort();\n                }\n                this.xhr = {};\n            }\n\n            var scope = this,\n                group,\n                groupData,\n                groupSource,\n                dataInStorage,\n                isValidStorage;\n\n            for (group in this.options.source) {\n                if (!this.options.source.hasOwnProperty(group)) continue;\n\n                groupSource = this.options.source[group];\n\n                // Get group source from Localstorage\n                if (this.options.cache) {\n\n                    dataInStorage = window[this.options.cache].getItem('TYPEAHEAD_' + this.node.selector + \":\" + group);\n\n                    if (dataInStorage) {\n                        if (this.options.compression) {\n                            dataInStorage = LZString.decompressFromUTF16(dataInStorage);\n                        }\n\n                        // In case the storage key:value are not readable anymore\n                        isValidStorage = false;\n                        try {\n                            dataInStorage = JSON.parse(dataInStorage + \"\");\n\n                            if (dataInStorage.data && dataInStorage.ttl > new Date().getTime()) {\n\n                                this.populateSource(dataInStorage.data, group);\n                                isValidStorage = true;\n\n                                // {debug}\n                                if (this.options.debug) {\n                                    _debug.log({\n                                        'node': this.node.selector,\n                                        'function': 'generateSource()',\n                                        'message': 'Source for group \"' + group + '\" found in ' + this.options.cache\n                                    });\n                                    _debug.print();\n                                }\n                                // {/debug}\n\n                            } else {\n                                window[this.options.cache].removeItem('TYPEAHEAD_' + this.node.selector + \":\" + group);\n                            }\n                        } catch (error) {\n                        }\n\n                        if (isValidStorage) continue;\n                    }\n                }\n\n                // Get group source from data\n                if (groupSource.data && !groupSource.ajax) {\n\n                    // #198 Add support for async data source\n                    if (typeof groupSource.data === \"function\") {\n\n                        groupData = groupSource.data.call(this);\n                        if (Array.isArray(groupData)) {\n                            scope.populateSource(groupData, group);\n                        } else if (typeof groupData.promise === \"function\") {\n                            (function (group) {\n                                $.when(groupData).then(function (deferredData) {\n                                    if (deferredData && Array.isArray(deferredData)) {\n                                        scope.populateSource(deferredData, group);\n                                    }\n                                });\n                            })(group);\n                        }\n                    } else {\n                        this.populateSource(\n                            $.extend(true, [], groupSource.data),\n                            group\n                        );\n                    }\n\n                    continue;\n                }\n\n                // Get group source from Ajax / JsonP\n                if (groupSource.ajax) {\n                    if (!this.requests[group]) {\n                        this.requests[group] = this.generateRequestObject(group);\n                    }\n                }\n            }\n\n            this.handleRequests();\n\n        },\n\n        generateRequestObject: function (group) {\n\n            var scope = this,\n                groupSource = this.options.source[group];\n\n            var xhrObject = {\n                request: {\n                    url: groupSource.ajax.url || null,\n                    dataType: 'json',\n                    beforeSend: function (jqXHR, options) {\n                        // Important to call .abort() in case of dynamic requests\n                        scope.xhr[group] = jqXHR;\n\n                        var beforeSend = scope.requests[group].callback.beforeSend || groupSource.ajax.beforeSend;\n                        typeof beforeSend === \"function\" && beforeSend.apply(null, arguments);\n                    }\n                },\n                callback: {\n                    beforeSend: null,\n                    done: null,\n                    fail: null,\n                    then: null,\n                    always: null\n                },\n                extra: {\n                    path: groupSource.ajax.path || null,\n                    group: group\n                },\n                validForGroup: [group]\n            };\n\n            if (typeof groupSource.ajax !== \"function\") {\n                if (groupSource.ajax instanceof Object) {\n                    xhrObject = this.extendXhrObject(xhrObject, groupSource.ajax);\n                }\n\n                if (Object.keys(this.options.source).length > 1) {\n                    for (var _group in this.requests) {\n                        if (!this.requests.hasOwnProperty(_group)) continue;\n                        if (this.requests[_group].isDuplicated) continue;\n\n                        if (xhrObject.request.url && xhrObject.request.url === this.requests[_group].request.url) {\n                            this.requests[_group].validForGroup.push(group);\n                            xhrObject.isDuplicated = true;\n                            delete xhrObject.validForGroup;\n                        }\n                    }\n                }\n            }\n\n            return xhrObject;\n\n        },\n\n        extendXhrObject: function (xhrObject, groupRequest) {\n\n            if (typeof groupRequest.callback === \"object\") {\n                xhrObject.callback = groupRequest.callback;\n                delete groupRequest.callback;\n            }\n\n            // #132 Fixed beforeSend when using a function as the request object\n            if (typeof groupRequest.beforeSend === \"function\") {\n                xhrObject.callback.beforeSend = groupRequest.beforeSend;\n                delete groupRequest.beforeSend;\n            }\n\n            // Fixes #105 Allow user to define their beforeSend function.\n            // Fixes #181 IE8 incompatibility\n            xhrObject.request = $.extend(true, xhrObject.request, groupRequest/*, {beforeSend: xhrObject.request.beforeSend}*/);\n\n            // JSONP needs a unique jsonpCallback to run concurrently\n            if (xhrObject.request.dataType.toLowerCase() === 'jsonp' && !xhrObject.request.jsonpCallback) {\n                xhrObject.request.jsonpCallback = 'callback_' + xhrObject.extra.group;\n            }\n\n            return xhrObject;\n\n        },\n\n        handleRequests: function () {\n\n            var scope = this,\n                requestsCount = Object.keys(this.requests).length;\n\n            if (this.helper.executeCallback.call(this, this.options.callback.onSendRequest, [this.node, this.query]) === false) {\n                this.isGenerated = null;\n                return;\n            }\n\n\n            for (var group in this.requests) {\n                if (!this.requests.hasOwnProperty(group)) continue;\n                if (this.requests[group].isDuplicated) continue;\n\n                (function (group, xhrObject) {\n\n                    if (typeof scope.options.source[group].ajax === \"function\") {\n\n                        var _groupRequest = scope.options.source[group].ajax.call(scope, scope.query);\n                        xhrObject = scope.extendXhrObject(xhrObject, _groupRequest);\n\n                        if (typeof xhrObject.request !== \"object\" || !xhrObject.request.url) {\n                            // {debug}\n                            if (scope.options.debug) {\n                                _debug.log({\n                                    'node': scope.node.selector,\n                                    'function': 'handleRequests',\n                                    'message': 'Source function must return an object containing \".url\" key for group \"' + group + '\"'\n                                });\n                                _debug.print();\n                            }\n                            // {/debug}\n                            return;\n                        }\n                    }\n\n                    var _request,\n                        _isExtended = false; // Prevent the main request from being changed\n\n                    if (~xhrObject.request.url.indexOf('{{query}}')) {\n                        if (!_isExtended) {\n                            xhrObject = $.extend(true, {}, xhrObject);\n                            _isExtended = true;\n                        }\n                        // #184 Invalid encoded characters on dynamic requests for `{{query}}`\n                        xhrObject.request.url = xhrObject.request.url.replace('{{query}}', encodeURIComponent(scope.query));\n                    }\n\n                    if (xhrObject.request.data) {\n                        for (var i in xhrObject.request.data) {\n                            if (!xhrObject.request.data.hasOwnProperty(i)) continue;\n                            if (~String(xhrObject.request.data[i]).indexOf('{{query}}')) {\n                                if (!_isExtended) {\n                                    xhrObject = $.extend(true, {}, xhrObject);\n                                    _isExtended = true;\n                                }\n                                // jQuery handles encodeURIComponent when the query is inside the data object\n                                xhrObject.request.data[i] = xhrObject.request.data[i].replace('{{query}}', scope.query);\n                                break;\n                            }\n                        }\n                    }\n\n                    $.ajax(xhrObject.request).done(function (data, textStatus, jqXHR) {\n\n                        var tmpData;\n                        for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {\n\n                            _request = scope.requests[xhrObject.validForGroup[i]];\n\n                            if (_request.callback.done instanceof Function) {\n\n                                tmpData = _request.callback.done(data, textStatus, jqXHR);\n                                data = Array.isArray(tmpData) && tmpData || data;\n\n                                // {debug}\n                                if (!Array.isArray(tmpData)) {\n                                    if (scope.options.debug) {\n                                        _debug.log({\n                                            'node': scope.node.selector,\n                                            'function': 'Ajax.callback.done()',\n                                            'message': 'Invalid returned data has to be an Array'\n                                        });\n                                        _debug.print();\n                                    }\n                                }\n                                // {/debug}\n                            }\n\n                        }\n\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\n\n                        for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {\n                            _request = scope.requests[xhrObject.validForGroup[i]];\n                            _request.callback.fail instanceof Function && _request.callback.fail(jqXHR, textStatus, errorThrown);\n                        }\n\n                        // {debug}\n                        if (scope.options.debug) {\n                            _debug.log({\n                                'node': scope.node.selector,\n                                'function': 'Ajax.callback.fail()',\n                                'arguments': JSON.stringify(xhrObject.request),\n                                'message': textStatus\n                            });\n\n                            console.log(errorThrown);\n\n                            _debug.print();\n                        }\n                        // {/debug}\n\n                    }).always(function (data, textStatus, jqXHR) {\n\n                        for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {\n                            _request = scope.requests[xhrObject.validForGroup[i]];\n                            _request.callback.always instanceof Function && _request.callback.always(data, textStatus, jqXHR);\n\n                            // #248 Aborted requests would call populate with invalid data\n                            if (typeof jqXHR === \"object\") {\n                                scope.populateSource(\n                                    typeof data.promise === \"function\" && [] || data,\n                                    _request.extra.group,\n                                    _request.extra.path || _request.request.path\n                                );\n                            }\n\n                            requestsCount -= 1;\n                            if (requestsCount === 0) {\n                                scope.helper.executeCallback.call(scope, scope.options.callback.onReceiveRequest, [scope.node, scope.query]);\n                            }\n\n                        }\n\n                    }).then(function (jqXHR, textStatus) {\n\n                        for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {\n                            _request = scope.requests[xhrObject.validForGroup[i]];\n                            _request.callback.then instanceof Function && _request.callback.then(jqXHR, textStatus);\n                        }\n\n                    });\n\n                }(group, this.requests[group]));\n\n            }\n\n        },\n\n        /**\n         * Build the source groups to be cycled for matched results\n         *\n         * @param {Array} data Array of Strings or Array of Objects\n         * @param {String} group\n         * @param {String} [path]\n         * @return {*}\n         */\n        populateSource: function (data, group, path) {\n\n            var scope = this,\n                groupSource = this.options.source[group],\n                extraData = groupSource.ajax && groupSource.data;\n\n            data = typeof path === \"string\" ? this.helper.namespace(path, data) : data;\n\n            if (typeof data === 'undefined') {\n                // {debug}\n                if (this.options.debug) {\n                    _debug.log({\n                        'node': this.node.selector,\n                        'function': 'populateSource()',\n                        'arguments': path,\n                        'message': 'Invalid data path.'\n                    });\n\n                    _debug.print();\n                }\n                // {/debug}\n            }\n\n            if (!Array.isArray(data)) {\n                // {debug}\n                if (this.options.debug) {\n                    _debug.log({\n                        'node': this.node.selector,\n                        'function': 'populateSource()',\n                        'arguments': JSON.stringify({group: group}),\n                        'message': 'Invalid data type, must be Array type.'\n                    });\n                    _debug.print();\n                }\n                // {/debug}\n                data = [];\n            }\n\n            if (extraData) {\n                if (typeof extraData === \"function\") {\n                    extraData = extraData();\n                }\n\n                if (Array.isArray(extraData)) {\n                    data = data.concat(extraData);\n                }\n                // {debug}\n                else {\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'populateSource()',\n                            'arguments': JSON.stringify(extraData),\n                            'message': 'WARNING - this.options.source.' + group + '.data Must be an Array or a function that returns an Array.'\n                        });\n\n                        _debug.print();\n                    }\n                }\n                // {/debug}\n            }\n\n            var tmpObj,\n                display = groupSource.display ?\n                    (groupSource.display[0] === 'compiled' ? groupSource.display[1] : groupSource.display[0]) :\n                    (this.options.display[0] === 'compiled' ? this.options.display[1] : this.options.display[0]);\n\n            for (var i = 0, ii = data.length; i < ii; i++) {\n                if (data[i] === null || typeof data[i] === \"boolean\") {\n                    _debug.log({\n                        'node': this.node.selector,\n                        'function': 'populateSource()',\n                        'message': 'WARNING - NULL/BOOLEAN value inside ' + group + '! The data was skipped.'\n                    });\n\n                    _debug.print();\n                    continue;\n                }\n                if (typeof data[i] === \"string\") {\n                    tmpObj = {};\n                    tmpObj[display] = data[i];\n                    data[i] = tmpObj;\n                }\n                data[i].group = group;\n            }\n\n            if (!this.options.dynamic && this.dropdownFilter.dynamic.length) {\n\n                var key,\n                    value,\n                    tmpValues = {};\n\n                for (var i = 0, ii = data.length; i < ii; i++) {\n                    for (var k = 0, kk = this.dropdownFilter.dynamic.length; k < kk; k++) {\n                        key = this.dropdownFilter.dynamic[k].key;\n\n                        value = data[i][key];\n                        if (!value) continue;\n                        if (!this.dropdownFilter.dynamic[k].value) {\n                            this.dropdownFilter.dynamic[k].value = [];\n                        }\n                        if (!tmpValues[key]) {\n                            tmpValues[key] = [];\n                        }\n                        if (!~tmpValues[key].indexOf(value.toLowerCase())) {\n                            tmpValues[key].push(value.toLowerCase());\n                            this.dropdownFilter.dynamic[k].value.push(value);\n                        }\n                    }\n                }\n            }\n\n            if (this.options.correlativeTemplate) {\n\n                var template = groupSource.template || this.options.template,\n                    compiledTemplate = \"\";\n\n                if (typeof template === \"function\") {\n                    template = template();\n                }\n\n                if (!template) {\n                    // {debug}\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'populateSource()',\n                            'arguments': JSON.stringify(group),\n                            'message': 'WARNING - this.options.correlativeTemplate is enabled but no template was found.'\n                        });\n\n                        _debug.print();\n                    }\n                    // {/debug}\n                } else {\n\n                    // #109 correlativeTemplate can be an array of display keys instead of the complete template\n                    if (Array.isArray(this.options.correlativeTemplate)) {\n                        for (var i = 0, ii = this.options.correlativeTemplate.length; i < ii; i++) {\n                            compiledTemplate += \"{{\" + this.options.correlativeTemplate[i] + \"}} \";\n                        }\n                    } else {\n                        compiledTemplate = template\n                            .replace(/<.+?>/g, '');\n                    }\n\n                    for (var i = 0, ii = data.length; i < ii; i++) {\n                        data[i].compiled = compiledTemplate.replace(/\\{\\{([\\w\\-\\.]+)(?:\\|(\\w+))?}}/g, function (match, index) {\n                                return scope.helper.namespace(index, data[i], 'get', '');\n                            }\n                        ).trim();\n                    }\n\n                    if (groupSource.display) {\n                        if (!~groupSource.display.indexOf('compiled')) {\n                            groupSource.display.unshift('compiled');\n                        }\n                    } else if (!~this.options.display.indexOf('compiled')) {\n                        this.options.display.unshift('compiled');\n                    }\n\n                }\n            }\n\n            if (this.options.callback.onPopulateSource) {\n                data = this.helper.executeCallback.call(this, this.options.callback.onPopulateSource, [this.node, data, group, path]);\n\n                // {debug}\n                if (!data || !Array.isArray(data)) {\n                    _debug.log({\n                        'node': this.node.selector,\n                        'function': 'callback.populateSource()',\n                        'message': 'callback.onPopulateSource must return the \"data\" parameter'\n                    });\n\n                    _debug.print();\n                }\n                // {/debug}\n            }\n\n            // Save the data inside a tmpSource var to later have the right order once every request are completed\n            this.tmpSource[group] = data;\n\n            if (this.options.cache && !window[this.options.cache].getItem('TYPEAHEAD_' + this.node.selector + \":\" + group)) {\n\n                if (this.options.callback.onCacheSave) {\n                    data = this.helper.executeCallback.call(this, this.options.callback.onCacheSave, [this.node, data, group, path]);\n\n                    // {debug}\n                    if (!data || !Array.isArray(data)) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'callback.populateSource()',\n                            'message': 'callback.onCacheSave must return the \"data\" parameter'\n                        });\n\n                        _debug.print();\n                    }\n                    // {/debug}\n                }\n\n                var storage = JSON.stringify({\n                    data: data,\n                    ttl: new Date().getTime() + this.options.ttl\n                });\n\n                if (this.options.compression) {\n                    storage = LZString.compressToUTF16(storage);\n                }\n\n                window[this.options.cache].setItem(\n                    'TYPEAHEAD_' + this.node.selector + \":\" + group,\n                    storage\n                );\n            }\n\n            this.incrementGeneratedGroup();\n\n        },\n\n        incrementGeneratedGroup: function () {\n\n            this.generatedGroupCount++;\n\n            if (this.groupCount !== this.generatedGroupCount) {\n                return;\n            }\n\n            this.isGenerated = true;\n\n            this.xhr = {};\n\n            var sourceKeys = Object.keys(this.options.source);\n\n            for (var i = 0, ii = sourceKeys.length; i < ii; i++) {\n                this.source[sourceKeys[i]] = this.tmpSource[sourceKeys[i]];\n            }\n\n            this.tmpSource = {};\n\n            if (!this.options.dynamic) {\n                this.buildDropdownItemLayout('dynamic');\n            }\n\n            this.options.loadingAnimation && this.container.removeClass('loading');\n\n            this.node.trigger('dynamic' + this.namespace);\n\n        },\n\n        /**\n         * Key Navigation\n         * tab 9: @TODO, what should tab do?\n         * Up 38: select previous item, skip \"group\" item\n         * Down 40: select next item, skip \"group\" item\n         * Right 39: change charAt, if last char fill hint (if options is true)\n         * Esc 27: clears input (is not empty) / blur (if empty)\n         * Enter 13: Select item + submit search\n         *\n         * @param {Object} e Event object\n         * @returns {*}\n         */\n        navigate: function (e) {\n\n            this.helper.executeCallback.call(this, this.options.callback.onNavigateBefore, [this.node, this.query, e]);\n\n            if (e.keyCode === 27) {\n                // #166 Different browsers do not have the same behaviors by default, lets enforce what we want instead\n                e.preventDefault();\n                if (this.query.length) {\n                    this.node.val('');\n                    this.node.trigger('input' + this.namespace, [e]);\n                } else {\n                    this.node.blur();\n                    this.hideLayout();\n                }\n                return;\n            }\n\n            if (!this.isGenerated || !this.result.length) return;\n\n            var itemList = this.resultContainer.find('.' + this.options.selector.item),\n                activeItem = itemList.filter('.active'),\n                activeItemIndex = activeItem[0] && itemList.index(activeItem) || null,\n                newActiveItemIndex = null;\n\n            if (e.keyCode === 13) {\n                if (activeItem.length > 0) {\n                    // Prevent form submit if an element is selected\n                    e.preventDefault();\n                    activeItem.find('a:first').trigger('click', e);\n                }\n                return;\n            }\n\n            if (e.keyCode === 39) {\n                if (activeItemIndex) {\n                    itemList.eq(activeItemIndex).find('a:first')[0].click();\n                } else if (this.options.hint &&\n                    this.hint.container.val() !== \"\" &&\n                    this.helper.getCaret(this.node[0]) >= this.query.length) {\n\n                    itemList.find('a[data-index=\"' + this.hintIndex + '\"]')[0].click();\n\n                }\n                return;\n            }\n\n            if (itemList.length > 0) {\n                activeItem.removeClass('active');\n            }\n\n            if (e.keyCode === 38) {\n\n                e.preventDefault();\n\n                if (activeItem.length > 0) {\n                    if (activeItemIndex - 1 >= 0) {\n                        newActiveItemIndex = activeItemIndex - 1;\n                        itemList.eq(newActiveItemIndex).addClass('active');\n                    }\n                } else {\n                    newActiveItemIndex = itemList.length - 1;\n                    itemList.last().addClass('active');\n                }\n\n            } else if (e.keyCode === 40) {\n\n                e.preventDefault();\n\n                if (activeItem.length > 0) {\n                    if (activeItemIndex + 1 < itemList.length) {\n                        newActiveItemIndex = activeItemIndex + 1;\n                        itemList.eq(newActiveItemIndex).addClass('active');\n                    }\n                } else {\n                    newActiveItemIndex = 0;\n                    itemList.first().addClass('active');\n                }\n            }\n\n            // #115 Prevent the input from changing when navigating (arrow up / down) the results\n            if (e.preventInputChange && ~[38, 40].indexOf(e.keyCode)) {\n                this.buildHintLayout(\n                    newActiveItemIndex !== null && newActiveItemIndex < this.result.length ?\n                        [this.result[newActiveItemIndex]] :\n                        null\n                );\n            }\n\n            if (this.options.hint && this.hint.container) {\n                this.hint.container.css(\n                    'color',\n                    e.preventInputChange ?\n                        this.hint.css.color :\n                    newActiveItemIndex === null && this.hint.css.color || this.hint.container.css('background-color') || 'fff'\n                );\n            }\n\n            this.node.val(\n                newActiveItemIndex !== null && !e.preventInputChange ?\n                    this.result[newActiveItemIndex][this.result[newActiveItemIndex].matchedKey] :\n                    this.rawQuery\n            );\n\n            this.helper.executeCallback.call(this, this.options.callback.onNavigateAfter, [\n                this.node,\n                itemList,\n                newActiveItemIndex !== null && itemList.eq(newActiveItemIndex).find('a:first') || undefined,\n                newActiveItemIndex !== null && this.result[newActiveItemIndex] || undefined,\n                this.query,\n                e\n            ]);\n\n        },\n\n        searchResult: function (preserveItem) {\n\n            // #54 In case the item is being clicked, we want to preserve it for onSubmit callback\n            if (!preserveItem) {\n                this.item = {};\n            }\n\n            this.resetLayout();\n\n            if (this.helper.executeCallback.call(this, this.options.callback.onSearch, [this.node, this.query]) === false) return;\n\n            if (this.query.length >= this.options.minLength) {\n                this.searchResultData();\n            }\n\n            this.helper.executeCallback.call(this, this.options.callback.onResult, [this.node, this.query, this.result, this.resultCount, this.resultCountPerGroup]);\n\n        },\n\n        searchResultData: function () {\n\n            var scope = this,\n                group,\n                groupBy = this.groupBy,\n                groupReference = null,\n                item,\n                match,\n                comparedDisplay,\n                comparedQuery = this.query.toLowerCase(),\n                maxItemPerGroup = this.options.maxItemPerGroup,\n                hasDynamicFilters = this.filters.dynamic && !this.helper.isEmpty(this.filters.dynamic),\n                displayKeys,\n                displayValue,\n                missingDisplayKey = {},\n                groupFilter,\n                groupFilterResult,\n                groupMatcher,\n                groupMatcherResult,\n                matcher = typeof this.options.matcher === \"function\" && this.options.matcher,\n                correlativeMatch,\n                correlativeQuery,\n                correlativeDisplay;\n\n            if (this.options.accent) {\n                comparedQuery = this.helper.removeAccent.call(this, comparedQuery);\n            }\n\n            for (group in this.source) {\n\n                if (!this.source.hasOwnProperty(group)) continue;\n                // dropdownFilter by source groups\n                if (this.filters.dropdown && this.filters.dropdown.key === \"group\" && this.filters.dropdown.value !== group) continue;\n\n                groupFilter = typeof this.options.source[group].filter !== \"undefined\" ? this.options.source[group].filter : this.options.filter;\n                groupMatcher = typeof this.options.source[group].matcher === \"function\" && this.options.source[group].matcher || matcher;\n\n                for (var k = 0, kk = this.source[group].length; k < kk; k++) {\n                    if (this.result.length >= this.options.maxItem && !this.options.callback.onResult) break;\n                    if (hasDynamicFilters && !this.dynamicFilter.validate.apply(this, [this.source[group][k]])) continue;\n\n                    item = this.source[group][k];\n                    // Validation over null item\n                    if (item === null || typeof item === \"boolean\") continue;\n\n                    // dropdownFilter by custom groups\n                    if (this.filters.dropdown && (item[this.filters.dropdown.key] || \"\").toLowerCase() !== (this.filters.dropdown.value || \"\").toLowerCase()) continue;\n\n                    groupReference = groupBy === \"group\" ? group : item[groupBy];\n\n                    if (groupReference && !this.result[groupReference]) {\n                        this.result[groupReference] = [];\n                        this.resultCountPerGroup[groupReference] = 0;\n                    }\n\n                    if (maxItemPerGroup) {\n                        if (groupBy === \"group\" && this.result[groupReference].length >= maxItemPerGroup && !this.options.callback.onResult) {\n                            break;\n                        }\n                    }\n\n                    displayKeys = this.options.source[group].display || this.options.display;\n\n                    for (var i = 0, ii = displayKeys.length; i < ii; i++) {\n\n                        // #183 Allow searching for deep source object keys\n                        displayValue = /\\./.test(displayKeys[i]) ?\n                            this.helper.namespace(displayKeys[i], item) :\n                            item[displayKeys[i]];\n\n                        // #182 Continue looping if empty or undefined key\n                        if (typeof displayValue === 'undefined' || displayValue === '') {\n                            // {debug}\n                            if (this.options.debug) {\n                                missingDisplayKey[i] = {\n                                    display: displayKeys[i],\n                                    data: item\n                                };\n                            }\n                            // {/debug}\n                            continue;\n                        }\n\n                        displayValue = this.helper.cleanStringFromScript(displayValue);\n\n                        if (typeof groupFilter === \"function\") {\n                            groupFilterResult = groupFilter.call(this, item, displayValue);\n\n                            // return undefined to skip to next item\n                            // return false to attempt the matching function on the next displayKey\n                            // return true to add the item to the result list\n                            // return item object to modify the item and add it to the result list\n\n                            if (groupFilterResult === undefined) break;\n                            if (!groupFilterResult) continue;\n                            if (typeof groupFilterResult === \"object\") {\n                                item = groupFilterResult;\n                            }\n                        }\n\n                        if (~[undefined, true].indexOf(groupFilter)) {\n                            comparedDisplay = displayValue;\n                            comparedDisplay = comparedDisplay.toString().toLowerCase();\n\n                            if (this.options.accent) {\n                                comparedDisplay = this.helper.removeAccent.call(this, comparedDisplay);\n                            }\n\n                            match = comparedDisplay.indexOf(comparedQuery);\n\n                            if (this.options.correlativeTemplate && displayKeys[i] === 'compiled' && match < 0 && /\\s/.test(comparedQuery)) {\n                                correlativeMatch = true;\n                                correlativeQuery = comparedQuery.split(' ');\n                                correlativeDisplay = comparedDisplay;\n                                for (var x = 0, xx = correlativeQuery.length; x < xx; x++) {\n                                    if (correlativeQuery[x] === \"\") continue;\n                                    if (!~correlativeDisplay.indexOf(correlativeQuery[x])) {\n                                        correlativeMatch = false;\n                                        break;\n                                    }\n                                    correlativeDisplay = correlativeDisplay.replace(correlativeQuery[x], '');\n                                }\n                            }\n\n                            if (match < 0 && !correlativeMatch) continue;\n                            // @TODO Deprecate these? use matcher instead?\n                            if (this.options.offset && match !== 0) continue;\n\n                            if (groupMatcher) {\n                                groupMatcherResult = groupMatcher.call(this, item, displayValue);\n\n                                // return undefined to skip to next item\n                                // return false to attempt the matching function on the next displayKey\n                                // return true to add the item to the result list\n                                // return item object to modify the item and add it to the result list\n\n                                if (groupMatcherResult === undefined) break;\n                                if (!groupMatcherResult) continue;\n                                if (typeof groupMatcherResult === \"object\") {\n                                    item = groupMatcherResult;\n                                }\n                            }\n                        }\n\n                        this.resultCount++;\n                        this.resultCountPerGroup[groupReference]++;\n\n                        if (this.resultItemCount < this.options.maxItem) {\n                            if (maxItemPerGroup && this.result[groupReference].length >= maxItemPerGroup) {\n                                break;\n                            }\n\n                            item.matchedKey = displayKeys[i];\n\n                            this.result[groupReference].push(item);\n                            this.resultItemCount++;\n                        }\n                        break;\n                    }\n\n                    if (!this.options.callback.onResult) {\n                        if (this.resultItemCount >= this.options.maxItem) {\n                            break;\n                        }\n                        if (maxItemPerGroup && this.result[groupReference].length >= maxItemPerGroup) {\n                            if (groupBy === \"group\") {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // {debug}\n            if (this.options.debug) {\n                if (!this.helper.isEmpty(missingDisplayKey)) {\n                    _debug.log({\n                        'node': this.node.selector,\n                        'function': 'searchResult()',\n                        'arguments': JSON.stringify(missingDisplayKey),\n                        'message': 'Missing keys for display, make sure options.display is set properly.'\n                    });\n\n                    _debug.print();\n                }\n            }\n            // {/debug}\n\n            if (this.options.order) {\n\n                var displayKeys = [],\n                    displayKey;\n\n                for (var group in this.result) {\n                    if (!this.result.hasOwnProperty(group)) continue;\n                    for (var i = 0, ii = this.result[group].length; i < ii; i++) {\n                        displayKey = this.options.source[this.result[group][i].group].display || this.options.display;\n                        if (!~displayKeys.indexOf(displayKey[0])) {\n                            displayKeys.push(displayKey[0]);\n                        }\n                    }\n                    this.result[group].sort(\n                        scope.helper.sort(\n                            displayKeys,\n                            scope.options.order === \"asc\",\n                            function (a) {\n                                return a.toString().toUpperCase();\n                            }\n                        )\n                    );\n                }\n\n            }\n\n            var concatResults = [],\n                groupOrder;\n\n            if (typeof this.options.groupOrder === \"function\") {\n                groupOrder = this.options.groupOrder.apply(this, [this.node, this.query, this.result, this.resultCount, this.resultCountPerGroup]);\n            } else if (Array.isArray(this.options.groupOrder)) {\n                groupOrder = this.options.groupOrder;\n            } else if (typeof this.options.groupOrder === \"string\" && ~[\"asc\", \"desc\"].indexOf(this.options.groupOrder)) {\n                groupOrder = Object.keys(this.result).sort(\n                    scope.helper.sort(\n                        [],\n                        scope.options.groupOrder === \"asc\",\n                        function (a) {\n                            return a.toString().toUpperCase();\n                        }\n                    )\n                );\n            } else {\n                groupOrder = Object.keys(this.result);\n            }\n\n            this.groups = groupOrder;\n\n            for (var i = 0, ii = groupOrder.length; i < ii; i++) {\n                concatResults = concatResults.concat(this.result[groupOrder[i]] || []);\n            }\n\n            this.result = concatResults;\n\n        },\n\n        buildLayout: function () {\n\n            this.buildHtmlLayout();\n\n            this.buildBackdropLayout();\n\n            this.buildHintLayout();\n\n            if (this.options.callback.onLayoutBuiltBefore) {\n                var tmpResultHtml = this.helper.executeCallback.call(this, this.options.callback.onLayoutBuiltBefore, [this.node, this.query, this.result, this.resultHtml]);\n\n                if (tmpResultHtml instanceof $) {\n                    this.resultHtml = tmpResultHtml;\n                }\n                // {debug}\n                else {\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': this.node.selector,\n                            'function': 'callback.onLayoutBuiltBefore()',\n                            'message': 'Invalid returned value - You must return resultHtmlList jQuery Object'\n                        });\n\n                        _debug.print();\n                    }\n                }\n                // {/debug}\n            }\n\n            this.resultHtml && this.resultContainer.html(this.resultHtml);\n\n            if (this.options.callback.onLayoutBuiltAfter) {\n                this.helper.executeCallback.call(this, this.options.callback.onLayoutBuiltAfter, [this.node, this.query, this.result]);\n            }\n        },\n\n        buildHtmlLayout: function () {\n            // #150 Add the option to have no resultList but still perform the search and trigger the callbacks\n            if (this.options.resultContainer === false) return;\n\n            if (!this.resultContainer) {\n                this.resultContainer = $(\"<div/>\", {\n                    \"class\": this.options.selector.result\n                });\n\n                this.container.append(this.resultContainer);\n            }\n\n            var emptyTemplate;\n            if (!this.result.length) {\n                if (this.options.emptyTemplate && this.query !== \"\") {\n                    emptyTemplate = typeof this.options.emptyTemplate === \"function\" ?\n                        this.options.emptyTemplate.call(this, this.query) :\n                        this.options.emptyTemplate.replace(/\\{\\{query}}/gi, this.helper.cleanStringFromScript(this.query));\n\n                } else {\n                    return;\n                }\n            }\n\n            var _query = this.query.toLowerCase();\n            if (this.options.accent) {\n                _query = this.helper.removeAccent.call(this, _query);\n            }\n\n            var scope = this,\n                groupTemplate = this.groupTemplate || '<ul></ul>',\n                hasEmptyTemplate = false;\n\n            if (this.groupTemplate) {\n                groupTemplate = $(groupTemplate.replace(/<([^>]+)>\\{\\{(.+?)}}<\\/[^>]+>/g, function (match, tag, group, offset, string) {\n                    var template = '',\n                        groups = group === \"group\" ? scope.groups : [group];\n\n                    if (!scope.result.length) {\n                        if (hasEmptyTemplate === true) return '';\n                        hasEmptyTemplate = true;\n\n                        return '<' + tag + ' class=\"' + scope.options.selector.empty + '\"><a href=\"javascript:;\">' + emptyTemplate + '</a></' + tag + '>';\n                    }\n\n                    for (var i = 0, ii = groups.length; i < ii; ++i) {\n                        template += '<' + tag + ' data-group-template=\"' + groups[i] + '\"><ul></ul></' + tag + '>';\n                    }\n\n                    return template;\n                }));\n            } else {\n                groupTemplate = $(groupTemplate);\n                if (!this.result.length) {\n                    groupTemplate.append(\n                        emptyTemplate instanceof $ ?\n                            emptyTemplate :\n                        '<li class=\"' + scope.options.selector.empty + '\"><a href=\"javascript:;\">' + emptyTemplate + '</a></li>'\n                    );\n                }\n            }\n\n            groupTemplate.addClass(this.options.selector.list + (this.helper.isEmpty(this.result) ? ' empty' : ''));\n\n            var _group,\n                _groupTemplate,\n                _item,\n                _href,\n                _liHtml,\n                _template,\n                _aHtml,\n                _display,\n                _displayKeys,\n                _displayValue,\n                _unusedGroups = this.groupTemplate && this.result.length && scope.groups || [],\n                _tmpIndexOf;\n\n            for (var i = 0, ii = this.result.length; i < ii; ++i) {\n\n                _item = this.result[i];\n                _group = _item.group;\n                _href = this.options.source[_item.group].href || this.options.href;\n                _display = [];\n                _displayKeys = this.options.source[_item.group].display || this.options.display;\n\n                // @TODO Optimize this, shouldn't occur on every looped item?\n                if (this.options.group) {\n                    _group = _item[this.options.group.key];\n                    if (this.options.group.template) {\n                        if (typeof this.options.group.template === \"function\") {\n                            _groupTemplate = this.options.group.template(_item);\n                        } else if (typeof this.options.template === \"string\") {\n                            _groupTemplate = this.options.group.template.replace(/\\{\\{([\\w\\-\\.]+)}}/gi, function (match, index) {\n                                return scope.helper.namespace(index, _item, 'get', '');\n                            });\n                        }\n                    }\n\n                    if (!groupTemplate.find('[data-search-group=\"' + _group + '\"]')[0]) {\n                        (this.groupTemplate ? groupTemplate.find('[data-group-template=\"' + _group + '\"] ul') : groupTemplate).append(\n                            $(\"<li/>\", {\n                                \"class\": scope.options.selector.group,\n                                \"html\": $(\"<a/>\", {\n                                    \"href\": \"javascript:;\",\n                                    \"html\": _groupTemplate || _group,\n                                    \"tabindex\": -1\n                                }),\n                                \"data-search-group\": _group\n                            })\n                        );\n                    }\n                }\n\n                if (this.groupTemplate && _unusedGroups.length) {\n                    _tmpIndexOf = _unusedGroups.indexOf(_group || _item.group);\n                    if (~_tmpIndexOf) {\n                        _unusedGroups.splice(_tmpIndexOf, 1);\n                    }\n                }\n\n                _liHtml = $(\"<li/>\", {\n                    \"class\": scope.options.selector.item + \" \" + scope.options.selector.group + '-' + this.helper.slugify.call(this, _group),\n                    \"html\": $(\"<a/>\", {\n                        // #190 Strange JS-code fragment in href attribute using jQuery version below 1.10\n                        \"href\": (function () {\n                            if (_href) {\n                                if (typeof _href === \"string\") {\n                                    _href = _href.replace(/\\{\\{([^\\|}]+)(?:\\|([^}]+))*}}/gi, function (match, index, options) {\n\n                                        var value = scope.helper.namespace(index, _item, 'get', '');\n\n                                        // #151 Slugify should be an option, not enforced\n                                        options = options && options.split(\"|\") || [];\n                                        if (~options.indexOf('slugify')) {\n                                            value = scope.helper.slugify.call(scope, value);\n                                        }\n\n                                        return value;\n                                    });\n                                } else if (typeof _href === \"function\") {\n                                    _href = _href(_item);\n                                }\n                                _item.href = _href;\n                            }\n                            return _href || \"javascript:;\";\n                        }()),\n                        \"data-group\": _group,\n                        \"data-index\": i,\n                        \"html\": function () {\n\n                            _template = (_item.group && scope.options.source[_item.group].template) || scope.options.template;\n\n                            if (_template) {\n                                if (typeof _template === \"function\") {\n                                    _template = _template.call(scope, scope.query, _item);\n                                }\n\n                                _aHtml = _template.replace(/\\{\\{([^\\|}]+)(?:\\|([^}]+))*}}/gi, function (match, index, options) {\n\n                                    var value = scope.helper.cleanStringFromScript(String(scope.helper.namespace(index, _item, 'get', '')));\n\n                                    // #151 Slugify should be an option, not enforced\n                                    options = options && options.split(\"|\") || [];\n                                    if (~options.indexOf('slugify')) {\n                                        value = scope.helper.slugify.call(scope, value);\n                                    }\n\n                                    if (!~options.indexOf('raw')) {\n                                        if (scope.options.highlight === true && _query && ~_displayKeys.indexOf(index)) {\n                                            value = scope.helper.highlight.call(scope, value, _query.split(\" \"), scope.options.accent);\n                                        }\n                                    }\n                                    return value;\n                                });\n                            } else {\n                                for (var i = 0, ii = _displayKeys.length; i < ii; i++) {\n                                    _displayValue = /\\./.test(_displayKeys[i]) ?\n                                        scope.helper.namespace(_displayKeys[i], _item) :\n                                        _item[_displayKeys[i]];\n\n                                    if (typeof _displayValue === 'undefined' || _displayValue === '') continue;\n\n                                    _display.push(_displayValue);\n                                }\n\n                                _aHtml = '<span class=\"' + scope.options.selector.display + '\">' + scope.helper.cleanStringFromScript(String(_display.join(\" \"))) + '</span>';\n                            }\n\n                            if ((scope.options.highlight === true && _query && !_template) || scope.options.highlight === \"any\") {\n                                _aHtml = scope.helper.highlight.call(scope, _aHtml, _query.split(\" \"), scope.options.accent);\n                            }\n\n                            $(this).append(_aHtml);\n\n                        }\n                    })\n                });\n\n                (function (i, item, liHtml) {\n                    liHtml.on('click', function (e, originalEvent) {\n                        // #208 - Attach \"keyboard Enter\" original event\n                        if (originalEvent && typeof originalEvent === \"object\") {\n                            e.originalEvent = originalEvent;\n                        }\n\n                        if (scope.options.mustSelectItem && scope.helper.isEmpty(item)) {\n                            e.preventDefault();\n                            return;\n                        }\n\n                        scope.item = item;\n\n                        if (scope.helper.executeCallback.call(scope, scope.options.callback.onClickBefore, [scope.node, $(this), item, e]) === false) return;\n                        if ((e.originalEvent && e.originalEvent.defaultPrevented) || e.isDefaultPrevented()) {\n                            return;\n                        }\n\n                        scope.query = scope.rawQuery = item[item.matchedKey].toString();\n\n                        scope.focusOnly = true;\n                        scope.node.val(scope.query).focus();\n\n                        scope.searchResult(true);\n                        scope.buildLayout();\n                        scope.hideLayout();\n\n                        scope.helper.executeCallback.call(scope, scope.options.callback.onClickAfter, [scope.node, $(this), item, e]);\n                    });\n                    liHtml.on('mouseenter', function (e) {\n                        scope.helper.executeCallback.call(scope, scope.options.callback.onMouseEnter, [scope.node, $(this), item, e]);\n                    });\n                    liHtml.on('mouseleave', function (e) {\n                        scope.helper.executeCallback.call(scope, scope.options.callback.onMouseLeave, [scope.node, $(this), item, e]);\n                    });\n                }(i, _item, _liHtml));\n\n                (this.groupTemplate ? groupTemplate.find('[data-group-template=\"' + _group + '\"] ul') : groupTemplate).append(_liHtml);\n            }\n\n            if (this.result.length && _unusedGroups.length) {\n                for (var i = 0, ii = _unusedGroups.length; i < ii; ++i) {\n                    groupTemplate.find('[data-group-template=\"' + _unusedGroups[i] + '\"]').remove();\n                }\n            }\n\n            this.resultHtml = groupTemplate;\n\n        },\n\n        buildBackdropLayout: function () {\n\n            if (!this.options.backdrop) return;\n\n            if (!this.backdrop.container) {\n                this.backdrop.css = $.extend(\n                    {\n                        \"opacity\": 0.6,\n                        \"filter\": 'alpha(opacity=60)',\n                        \"position\": 'fixed',\n                        \"top\": 0,\n                        \"right\": 0,\n                        \"bottom\": 0,\n                        \"left\": 0,\n                        \"z-index\": 1040,\n                        \"background-color\": \"#000\"\n                    },\n                    this.options.backdrop\n                );\n\n                this.backdrop.container = $(\"<div/>\", {\n                    \"class\": this.options.selector.backdrop,\n                    \"css\": this.backdrop.css\n                }).insertAfter(this.container);\n\n            }\n            this.container\n                .addClass('backdrop')\n                .css({\n                    \"z-index\": this.backdrop.css[\"z-index\"] + 1,\n                    \"position\": \"relative\"\n                });\n\n        },\n\n        buildHintLayout: function (result) {\n            if (!this.options.hint) return;\n            // #144 hint doesn't overlap with the input when the query is too long\n            if (this.node[0].scrollWidth > Math.ceil(this.node.innerWidth())) {\n                this.hint.container && this.hint.container.val(\"\");\n                return;\n            }\n\n            var scope = this,\n                hint = \"\",\n                result = result || this.result,\n                query = this.query.toLowerCase();\n\n            if (this.options.accent) {\n                query = this.helper.removeAccent.call(this, query);\n            }\n\n            this.hintIndex = null;\n\n            if (this.query.length >= this.options.minLength) {\n\n                if (!this.hint.container) {\n\n                    this.hint.css = $.extend({\n                            \"border-color\": \"transparent\",\n                            \"position\": \"absolute\",\n                            \"top\": 0,\n                            \"display\": \"inline\",\n                            \"z-index\": -1,\n                            \"float\": \"none\",\n                            \"color\": \"silver\",\n                            \"box-shadow\": \"none\",\n                            \"cursor\": \"default\",\n                            \"-webkit-user-select\": \"none\",\n                            \"-moz-user-select\": \"none\",\n                            \"-ms-user-select\": \"none\",\n                            \"user-select\": \"none\"\n                        },\n                        this.options.hint\n                    );\n\n                    this.hint.container = $('<input/>', {\n                        'type': this.node.attr('type'),\n                        'class': this.node.attr('class'),\n                        'readonly': true,\n                        'unselectable': 'on',\n                        'aria-hidden': 'true',\n                        'tabindex': -1,\n                        'click': function () {\n                            // IE8 Fix\n                            scope.node.focus();\n                        }\n                    }).addClass(this.options.selector.hint)\n                        .css(this.hint.css)\n                        .insertAfter(this.node);\n\n                    this.node.parent().css({\n                        \"position\": \"relative\"\n                    });\n                }\n\n                this.hint.container.css('color', this.hint.css.color);\n\n                // Do not display hint for empty query\n                if (query) {\n                    var _displayKeys,\n                        _group,\n                        _comparedValue;\n\n                    for (var i = 0, ii = result.length; i < ii; i++) {\n\n                        _group = result[i].group;\n                        _displayKeys = this.options.source[_group].display || this.options.display;\n\n                        for (var k = 0, kk = _displayKeys.length; k < kk; k++) {\n\n                            _comparedValue = String(result[i][_displayKeys[k]]).toLowerCase();\n                            if (this.options.accent) {\n                                _comparedValue = this.helper.removeAccent.call(this, _comparedValue);\n                            }\n\n                            if (_comparedValue.indexOf(query) === 0) {\n                                hint = String(result[i][_displayKeys[k]]);\n                                this.hintIndex = i;\n                                break;\n                            }\n                        }\n                        if (this.hintIndex !== null) {\n                            break;\n                        }\n                    }\n                }\n\n                this.hint.container\n                    .val(hint.length > 0 && this.rawQuery + hint.substring(this.query.length) || \"\");\n\n            }\n\n        },\n\n        buildDropdownLayout: function () {\n\n            if (!this.options.dropdownFilter) {\n                return;\n            }\n\n            var scope = this;\n\n            $('<span/>', {\n                \"class\": this.options.selector.filter,\n                \"html\": function () {\n\n                    $(this).append(\n                        $('<button/>', {\n                            \"type\": \"button\",\n                            \"class\": scope.options.selector.filterButton,\n                            \"style\": \"display: none;\",\n                            \"click\": function (e) {\n                                e.stopPropagation();\n                                scope.container.toggleClass('filter');\n\n                                var _ns = scope.namespace + '-dropdown-filter';\n\n                                $('html').off(_ns);\n\n                                if (scope.container.hasClass('filter')) {\n                                    $('html').on(\"click\" + _ns + \" touchend\" + _ns, function (e) {\n                                        if ($(e.target).closest('.' + scope.options.selector.filter)[0] || scope.hasDragged) return;\n                                        scope.container.removeClass('filter');\n                                    });\n                                }\n                            }\n                        })\n                    );\n\n                    $(this).append(\n                        $('<ul/>', {\n                            \"class\": scope.options.selector.dropdown\n                        })\n                    );\n                }\n            }).insertAfter(scope.container.find('.' + scope.options.selector.query));\n\n        },\n\n        buildDropdownItemLayout: function (type) {\n\n            var scope = this,\n                template,\n                all = typeof this.options.dropdownFilter === 'string' && this.options.dropdownFilter || 'All',\n                ulScope = this.container.find('.' + this.options.selector.dropdown),\n                filter;\n\n            // Use regular groups defined in options.source\n            if (type === 'static' && this.options.dropdownFilter === true || typeof this.options.dropdownFilter === 'string') {\n                this.dropdownFilter.static.push({\n                    key: 'group',\n                    template: '{{group}}',\n                    all: all,\n                    value: Object.keys(this.options.source)\n                });\n            }\n\n            for (var i = 0, ii = this.dropdownFilter[type].length; i < ii; i++) {\n\n                filter = this.dropdownFilter[type][i];\n\n                if (!Array.isArray(filter.value)) {\n                    filter.value = [filter.value];\n                }\n\n                if (filter.all) {\n                    this.dropdownFilterAll = filter.all;\n                }\n\n                for (var k = 0, kk = filter.value.length; k <= kk; k++) {\n\n                    // Only add \"all\" at the last filter iteration\n                    if (k === kk && (i !== ii - 1)) {\n                        continue;\n                    } else if (k === kk && (i === ii - 1)) {\n                        if (type === 'static' && this.dropdownFilter.dynamic.length) {\n                            continue;\n                        }\n                    }\n\n                    template = this.dropdownFilterAll || all;\n                    if (filter.value[k]) {\n                        if (filter.template) {\n                            template = filter.template.replace(new RegExp('\\{\\{' + filter.key + '}}', 'gi'), filter.value[k]);\n                        } else {\n                            template = filter.value[k];\n                        }\n                    } else {\n                        this.container.find('.' + scope.options.selector.filterButton).html(template);\n                    }\n\n                    (function (k, filter, template) {\n\n                        ulScope.append(\n                            $(\"<li/>\", {\n                                \"class\": scope.options.selector.dropdownItem + ' ' + scope.helper.slugify.call(scope, filter.key + '-' + (filter.value[k] || all)),\n                                \"html\": $(\"<a/>\", {\n                                    \"href\": \"javascript:;\",\n                                    \"html\": template,\n                                    \"click\": function (e) {\n                                        e.preventDefault();\n                                        _selectFilter.call(scope, {\n                                            key: filter.key,\n                                            value: filter.value[k] || '*',\n                                            template: template\n                                        });\n                                    }\n                                })\n                            })\n                        );\n\n                    }(k, filter, template));\n                }\n            }\n\n            if (this.dropdownFilter[type].length) {\n                this.container.find('.' + scope.options.selector.filterButton).removeAttr('style');\n            }\n\n            /**\n             * @private\n             * Select the filter and rebuild the result group\n             *\n             * @param {object} item\n             */\n            function _selectFilter(item) {\n                if (item.value === \"*\") {\n                    delete this.filters.dropdown;\n                } else {\n                    this.filters.dropdown = item;\n                }\n\n                this.container\n                    .removeClass('filter')\n                    .find('.' + this.options.selector.filterButton)\n                    .html(item.template);\n\n                this.node.trigger('dynamic' + this.namespace);\n\n                this.node.focus();\n            }\n        },\n\n        dynamicFilter: {\n            isEnabled: false,\n            init: function () {\n\n                if (!this.options.dynamicFilter) return;\n\n                this.dynamicFilter.bind.call(this);\n                this.dynamicFilter.isEnabled = true;\n\n            },\n\n            validate: function (item) {\n\n                var isValid,\n                    softValid = null,\n                    hardValid = null,\n                    itemValue;\n\n                for (var key in this.filters.dynamic) {\n                    if (!this.filters.dynamic.hasOwnProperty(key)) continue;\n                    if (!!~key.indexOf('.')) {\n                        itemValue = this.helper.namespace(key, item, 'get');\n                    } else {\n                        itemValue = item[key];\n                    }\n\n                    if (this.filters.dynamic[key].modifier === '|' && !softValid) {\n                        softValid = itemValue == this.filters.dynamic[key].value || false;\n                    }\n\n                    if (this.filters.dynamic[key].modifier === '&') {\n                        // Leaving \"==\" in case of comparing number with string\n                        if (itemValue == this.filters.dynamic[key].value) {\n                            hardValid = true;\n                        } else {\n                            hardValid = false;\n                            break;\n                        }\n                    }\n                }\n\n                isValid = softValid;\n                if (hardValid !== null) {\n                    isValid = hardValid;\n                    if (hardValid === true && softValid !== null) {\n                        isValid = softValid;\n                    }\n                }\n\n                return !!isValid;\n\n            },\n\n            set: function (key, value) {\n\n                var matches = key.match(/^([|&])?(.+)/);\n\n                if (!value) {\n                    delete this.filters.dynamic[matches[2]];\n                } else {\n                    this.filters.dynamic[matches[2]] = {\n                        modifier: matches[1] || '|',\n                        value: value\n                    };\n                }\n\n                if (this.dynamicFilter.isEnabled) {\n                    this.searchResult();\n                    this.buildLayout();\n                }\n\n            },\n            bind: function () {\n\n                var scope = this,\n                    filter;\n\n                for (var i = 0, ii = this.options.dynamicFilter.length; i < ii; i++) {\n\n                    filter = this.options.dynamicFilter[i];\n\n                    if (typeof filter.selector === \"string\") {\n                        filter.selector = $(filter.selector);\n                    }\n\n                    if (!(filter.selector instanceof $) || !filter.selector[0] || !filter.key) {\n                        // {debug}\n                        if (this.options.debug) {\n                            _debug.log({\n                                'node': this.node.selector,\n                                'function': 'buildDynamicLayout()',\n                                'message': 'Invalid jQuery selector or jQuery Object for \"filter.selector\" or missing filter.key'\n                            });\n\n                            _debug.print();\n                        }\n                        // {/debug}\n                        continue;\n                    }\n\n                    (function (filter) {\n                        filter.selector.off(scope.namespace).on('change' + scope.namespace, function () {\n                            scope.dynamicFilter.set.apply(scope, [filter.key, scope.dynamicFilter.getValue(this)]);\n                        }).trigger('change' + scope.namespace);\n                    }(filter));\n\n                }\n            },\n\n            getValue: function (tag) {\n                var value;\n                if (tag.tagName === \"SELECT\") {\n                    value = tag.value;\n                } else if (tag.tagName === \"INPUT\") {\n                    if (tag.type === \"checkbox\") {\n                        value = tag.checked && tag.getAttribute('value') || tag.checked || null;\n                    } else if (tag.type === \"radio\" && tag.checked) {\n                        value = tag.value;\n                    }\n                }\n                return value;\n            }\n        },\n\n        showLayout: function () {\n\n            // Means the container is already visible\n            if (this.container.hasClass('result')) return;\n\n            // Do not add display classes if there are no results\n            if (!this.result.length && !this.options.emptyTemplate && !this.options.backdropOnFocus) {\n                return;\n            }\n\n            var scope = this;\n\n            $('html').off(this.namespace)\n                .on(\"click\" + this.namespace + \" touchend\" + this.namespace, function (e) {\n                    if ($(e.target).closest(scope.container)[0] || scope.hasDragged) return;\n                    scope.hideLayout();\n                });\n\n            this.container.addClass([\n                this.result.length || (this.options.emptyTemplate && this.query.length >= this.options.minLength) ? 'result ' : '',\n                this.options.hint && this.query.length >= this.options.minLength ? 'hint' : '',\n                this.options.backdrop || this.options.backdropOnFocus ? 'backdrop' : ''].join(' ')\n            );\n\n            this.helper.executeCallback.call(this, this.options.callback.onShowLayout, [this.node, this.query]);\n\n        },\n\n        hideLayout: function () {\n\n            // Means the container is already hidden\n            if (!this.container.hasClass('result') && !this.container.hasClass('backdrop')) return;\n\n            this.container.removeClass('result hint filter' + (this.options.backdropOnFocus && $(this.node).is(':focus') ? '' : ' backdrop'));\n\n            if (this.options.backdropOnFocus && this.container.hasClass('backdrop')) return;\n\n            // Make sure the event gets cleared in case of \"ESC\"\n            $('html').off(this.namespace);\n\n            this.helper.executeCallback.call(this, this.options.callback.onHideLayout, [this.node, this.query]);\n\n        },\n\n        resetLayout: function () {\n\n            this.result = {};\n            this.resultCount = 0;\n            this.resultCountPerGroup = {};\n            this.resultItemCount = 0;\n            this.resultHtml = null;\n\n            if (this.options.hint && this.hint.container) {\n                this.hint.container.val('');\n            }\n\n        },\n\n        buildCancelButtonLayout: function () {\n            if (!this.options.cancelButton) return;\n            var scope = this;\n\n            $('<span/>', {\n                \"class\": this.options.selector.cancelButton,\n                \"mousedown\": function (e) {\n                    // Don't blur the input\n                    e.stopImmediatePropagation();\n                    e.preventDefault();\n\n                    scope.node.val('');\n                    scope.node.trigger('input' + scope.namespace, [e]);\n                }\n            }).insertBefore(this.node);\n\n        },\n\n        toggleCancelButton: function () {\n            this.container.toggleClass('cancel', !!this.query.length);\n        },\n\n        __construct: function () {\n            this.extendOptions();\n\n            if (!this.unifySourceFormat()) {\n                return;\n            }\n\n            this.dynamicFilter.init.apply(this);\n\n            this.init();\n            this.delegateEvents();\n            this.buildCancelButtonLayout();\n            this.buildDropdownLayout();\n            this.buildDropdownItemLayout('static');\n\n            this.helper.executeCallback.call(this, this.options.callback.onReady, [this.node]);\n        },\n\n        helper: {\n\n            isEmpty: function (obj) {\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        return false;\n                }\n\n                return true;\n            },\n\n            /**\n             * Remove every accent(s) from a string\n             *\n             * @param {String} string\n             * @returns {*}\n             */\n            removeAccent: function (string) {\n                if (typeof string !== \"string\") {\n                    return;\n                }\n\n                var accent = _accent;\n\n                if (typeof this.options.accent === \"object\") {\n                    accent = this.options.accent;\n                }\n\n                string = string.toLowerCase().replace(new RegExp('[' + accent.from + ']', 'g'), function (match) {\n                    return accent.to[accent.from.indexOf(match)];\n                });\n\n                return string;\n            },\n\n            /**\n             * Creates a valid url from string\n             *\n             * @param {String} string\n             * @returns {string}\n             */\n            slugify: function (string) {\n\n                string = String(string);\n\n                if (string !== \"\") {\n                    string = this.helper.removeAccent.call(this, string);\n                    string = string.replace(/[^-a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');\n                }\n\n                return string;\n            },\n\n            /**\n             * Sort list of object by key\n             *\n             * @param {String|Array} field\n             * @param {Boolean} reverse\n             * @param {Function} primer\n             * @returns {Function}\n             */\n            sort: function (field, reverse, primer) {\n                var key = function (x) {\n                    for (var i = 0, ii = field.length; i < ii; i++) {\n                        if (typeof x[field[i]] !== 'undefined') {\n                            return primer(x[field[i]]);\n                        }\n                    }\n                    return x;\n                };\n\n                reverse = [-1, 1][+!!reverse];\n\n                return function (a, b) {\n                    return a = key(a), b = key(b), reverse * ((a > b) - (b > a));\n                };\n            },\n\n            /**\n             * Replace a string from-to index\n             *\n             * @param {String} string The complete string to replace into\n             * @param {Number} offset The cursor position to start replacing from\n             * @param {Number} length The length of the replacing string\n             * @param {String} replace The replacing string\n             * @returns {String}\n             */\n            replaceAt: function (string, offset, length, replace) {\n                return string.substring(0, offset) + replace + string.substring(offset + length);\n            },\n\n            /**\n             * Adds <strong> html around a matched string\n             *\n             * @param {String} string The complete string to match from\n             * @param {String} key\n             * @param {Boolean} [accents]\n             * @returns {*}\n             */\n            highlight: function (string, keys, accents) {\n\n                string = String(string);\n\n                var searchString = accents && this.helper.removeAccent.call(this, string) || string,\n                    matches = [];\n\n                if (!Array.isArray(keys)) {\n                    keys = [keys];\n                }\n\n                keys.sort(function (a, b) {\n                    return b.length - a.length;\n                });\n\n                // Make sure the '|' join will be safe!\n                for (var i = keys.length - 1; i >= 0; i--) {\n                    if (keys[i].trim() === \"\") {\n                        keys.splice(i, 1);\n                        continue;\n                    }\n                    keys[i] = keys[i].replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n                }\n\n                searchString.replace(\n                    new RegExp('(?:' + keys.join('|') + ')(?!([^<]+)?>)', 'gi'),\n                    function (match, index, offset) {\n                        matches.push({\n                            offset: offset,\n                            length: match.length\n                        });\n                    }\n                );\n\n                for (var i = matches.length - 1; i >= 0; i--) {\n                    string = this.helper.replaceAt(\n                        string,\n                        matches[i].offset,\n                        matches[i].length,\n                        \"<strong>\" + string.substr(matches[i].offset, matches[i].length) + \"</strong>\"\n                    );\n                }\n\n                return string;\n            },\n\n            /**\n             * Get carret position, mainly used for right arrow navigation\n             * @param element\n             * @returns {*}\n             */\n            getCaret: function (element) {\n                if (element.selectionStart) {\n                    return element.selectionStart;\n                } else if (document.selection) {\n                    element.focus();\n\n                    var r = document.selection.createRange();\n                    if (r === null) {\n                        return 0;\n                    }\n\n                    var re = element.createTextRange(),\n                        rc = re.duplicate();\n                    re.moveToBookmark(r.getBookmark());\n                    rc.setEndPoint('EndToStart', re);\n\n                    return rc.text.length;\n                }\n                return 0;\n            },\n\n            /**\n             * Clean strings from possible XSS (script and iframe tags)\n             * @param string\n             * @returns {string}\n             */\n            cleanStringFromScript: function (string) {\n                return typeof string === \"string\" &&\n                    string.replace(/<\\/?(?:script|iframe)\\b[^>]*>/gm, '') ||\n                    string;\n            },\n\n            /**\n             * Executes an anonymous function or a string reached from the window scope.\n             *\n             * @example\n             * Note: These examples works with every configuration callbacks\n             *\n             * // An anonymous function inside the \"onInit\" option\n             * onInit: function() { console.log(':D'); };\n             *\n             * // myFunction() located on window.coucou scope\n             * onInit: 'window.coucou.myFunction'\n             *\n             * // myFunction(a,b) located on window.coucou scope passing 2 parameters\n             * onInit: ['window.coucou.myFunction', [':D', ':)']];\n             *\n             * // Anonymous function to execute a local function\n             * onInit: function () { myFunction(':D'); }\n             *\n             * @param {String|Array} callback The function to be called\n             * @param {Array} [extraParams] In some cases the function can be called with Extra parameters (onError)\n             * @returns {*}\n             */\n            executeCallback: function (callback, extraParams) {\n\n                if (!callback) {\n                    return;\n                }\n\n                var _callback;\n\n                if (typeof callback === \"function\") {\n\n                    _callback = callback;\n\n                } else if (typeof callback === \"string\" || Array.isArray(callback)) {\n\n                    if (typeof callback === \"string\") {\n                        callback = [callback, []];\n                    }\n\n                    _callback = this.helper.namespace(callback[0], window);\n\n                    if (typeof _callback !== \"function\") {\n                        // {debug}\n                        if (this.options.debug) {\n                            _debug.log({\n                                'node': this.selector,\n                                'function': 'executeCallback()',\n                                'arguments': JSON.stringify(callback),\n                                'message': 'WARNING - Invalid callback function\"'\n                            });\n\n                            _debug.print();\n                        }\n                        // {/debug}\n                        return;\n                    }\n\n                }\n\n                return _callback.apply(this, (callback[1] || []).concat(extraParams ? extraParams : []));\n\n            },\n\n            namespace: function (namespaceString, objectReference, method, objectValue) {\n\n                if (typeof namespaceString !== \"string\" || namespaceString === \"\") {\n                    // {debug}\n                    if (this.options.debug) {\n                        _debug.log({\n                            'node': _node.selector,\n                            'function': 'namespace()',\n                            'arguments': namespaceString,\n                            'message': 'ERROR - Missing namespaceString\"'\n                        });\n\n                        _debug.print();\n                    }\n                    // {/debug}\n                    return false;\n                }\n\n                var parts = namespaceString.split('.'),\n                    parent = objectReference || window,\n                    method = method || 'get',\n                    value = objectValue || {},\n                    currentPart = '';\n\n                for (var i = 0, length = parts.length; i < length; i++) {\n                    currentPart = parts[i];\n\n                    if (typeof parent[currentPart] === \"undefined\") {\n                        if (~['get', 'delete'].indexOf(method)) {\n                            return typeof objectValue !== \"undefined\" ? objectValue : undefined;\n                        }\n                        parent[currentPart] = {};\n                    }\n\n                    if (~['set', 'create', 'delete'].indexOf(method)) {\n                        if (i === length - 1) {\n                            if (method === 'set' || method === 'create') {\n                                parent[currentPart] = value;\n                            } else {\n\n                                delete parent[currentPart];\n                                return true;\n                            }\n                        }\n                    }\n\n                    parent = parent[currentPart];\n\n                }\n                return parent;\n            },\n\n            typeWatch: (function () {\n                var timer = 0;\n                return function (callback, ms) {\n                    clearTimeout(timer);\n                    timer = setTimeout(callback, ms);\n                };\n            })()\n\n        }\n    };\n\n    /**\n     * @public\n     * Implement Typeahead on the selected input node.\n     *\n     * @param {Object} options\n     * @return {Object} Modified DOM element\n     */\n    $.fn.typeahead = $.typeahead = function (options) {\n        return _api.typeahead(this, options);\n    };\n\n    /**\n     * @private\n     * API to handles Typeahead methods via jQuery.\n     */\n    var _api = {\n\n        /**\n         * Enable Typeahead\n         *\n         * @param {Object} node\n         * @param {Object} options\n         * @returns {*}\n         */\n        typeahead: function (node, options) {\n\n            if (!options || !options.source || typeof options.source !== 'object') {\n\n                // {debug}\n                _debug.log({\n                    'node': node.selector || options && options.input,\n                    'function': '$.typeahead()',\n                    'arguments': JSON.stringify(options && options.source || ''),\n                    'message': 'Undefined \"options\" or \"options.source\" or invalid source type - Typeahead dropped'\n                });\n\n                _debug.print();\n                // {/debug}\n\n                return;\n            }\n\n            if (typeof node === \"function\") {\n                if (!options.input) {\n\n                    // {debug}\n                    _debug.log({\n                        'node': node.selector,\n                        'function': '$.typeahead()',\n                        //'arguments': JSON.stringify(options),\n                        'message': 'Undefined \"options.input\" - Typeahead dropped'\n                    });\n\n                    _debug.print();\n                    // {/debug}\n\n                    return;\n                }\n\n                node = $(options.input);\n            }\n\n            if (!node.length || node[0].nodeName !== \"INPUT\") {\n\n                // {debug}\n                _debug.log({\n                    'node': node.selector,\n                    'function': '$.typeahead()',\n                    'arguments': JSON.stringify(options.input),\n                    'message': 'Unable to find jQuery input element - Typeahead dropped'\n                });\n\n                _debug.print();\n                // {/debug}\n\n                return;\n            }\n\n            // Forcing node.selector... damn you jQuery...\n            if (options.input && !node.selector) {\n                node.selector = options.input;\n            }\n\n            /*jshint boss:true */\n            return window.Typeahead[options.input || node.selector] = new Typeahead(node, options);\n\n        }\n\n    };\n\n// {debug}\n    var _debug = {\n\n        table: {},\n        log: function (debugObject) {\n\n            if (!debugObject.message || typeof debugObject.message !== \"string\") {\n                return;\n            }\n\n            this.table[debugObject.message] = $.extend({\n                'node': '',\n                'function': '',\n                'arguments': ''\n            }, debugObject);\n\n        },\n        print: function () {\n\n            if (Typeahead.prototype.helper.isEmpty(this.table) || !console || !console.table) {\n                return;\n            }\n\n            if (console.group !== undefined || console.table !== undefined) {\n                console.groupCollapsed('--- jQuery Typeahead Debug ---');\n                console.table(this.table);\n                console.groupEnd();\n            }\n\n            this.table = {};\n\n        }\n\n    };\n    _debug.log({\n        'message': 'WARNING - You are using the DEBUG version. Use /dist/jquery.typeahead.min.js in production.'\n    });\n\n    _debug.print();\n// {/debug}\n\n// IE8 Shims\n    window.console = window.console || {\n            log: function () {\n            }\n        };\n\n    if (!Array.isArray) {\n        Array.isArray = function (arg) {\n            return Object.prototype.toString.call(arg) === '[object Array]';\n        };\n    }\n\n    if (!('trim' in String.prototype)) {\n        String.prototype.trim = function () {\n            return this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n        };\n    }\n    if (!('indexOf' in Array.prototype)) {\n        Array.prototype.indexOf = function (find, i /*opt*/) {\n            if (i === undefined) i = 0;\n            if (i < 0) i += this.length;\n            if (i < 0) i = 0;\n            for (var n = this.length; i < n; i++)\n                if (i in this && this[i] === find)\n                    return i;\n            return -1;\n        };\n    }\n    if (!Object.keys) {\n        Object.keys = function (obj) {\n            var keys = [],\n                k;\n            for (k in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, k)) {\n                    keys.push(k);\n                }\n            }\n            return keys;\n        };\n    }\n\n    return Typeahead;\n\n}));\n"]}